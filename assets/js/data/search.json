[
  
  {
    "title": "Asynchronous programming note in .NET",
    "url": "/posts/async-programming-in-dotnet/",
    "categories": "dotnet",
    "tags": "asynchronous prgramming",
    "date": "2024-12-01 00:34:00 +0800",
    





    
    "snippet": "BackgroundAsynchronous programming has been around for a while, we can see them everywhere.  It was invented to improve the responsiveness of applications and overall user experience; In another wo...",
    "content": "BackgroundAsynchronous programming has been around for a while, we can see them everywhere.  It was invented to improve the responsiveness of applications and overall user experience; In another word, no user would like to see a frozen screen.  As a programmer, it takes me a bit effort to fully understand the concept, its implementation and mechanism.What I am trying to sayWhether you are a new to programming or a developer, you probably have read the following sentence.  “Asynchronous Programming is not about blocking something, but waiting for something to be finished.”I had a few questions in my mind when I read this and my questions are:  What is the thing it is not trying to block?  What is the thing it is waiting for?My confusion cleared up after understanding how it works and identifying what confused me. I will include my study notes in this article, and hopefully, they will help you fully understand asynchronous programming in .NET.How does it workBefore we dive into how asynchronous programming works, there are a few key terms we need to understand. I am not attempting to elaborate on the official documentation, but instead sharing my own notes.Thread vs TaskA task is some work that is being done, or it can be running or it can be waited.  Compiler will wrap the asynchronous function into a Task object.  The good thing is, as developers, we don’t need to worry about how it is done.A thread is the smallest unit of execution.  In my mind, I always think a thread is a compartment of a train.Async vs AwaitAsync - if a method is decorate with async keyword, the compiler is allowed to invisibly break the metho into pieces that can be paused and resumed as needed.  I will explain what ‘paused’ and ‘resumed’ mean in this context shortly.Await - A method or function reaches a point where it needs an operation to complete before it can continue.  (Many documents or articles use background operation; it can confuse junior developrs easily, and this is where I got tripped.  I still remember that I keep asking senior developers, “how come it starts an background operation??? Why???”  In my opinion, we are focusing on the main flow of the method; we don’t necessarily refer it as a background operation, we could just treat as a normal operation)In the meantime, while waiting for the operation to finish, the thread running this method can perform other tasks, or remain idle.  Technically, remain idle is a task as well.Once the operation is complete, the thread resumes executing from where it left off, rather than starting from the beginning of the method.Hopefully, you are still with me.Pause - the method stop running the current method; in regard to what is the thread doing now? Either doing other jobs or remain idle, none of our business.Resume - Once the required operation is finished, the thread will resume the execution.ExampleGeneric Exampleasync void button_click(object sender, EventArg e) {    statusLabel.text = \"Start downloading\";    await downloadFile = someHttpDownloadTaskAsync();    statusLabel.text = \"Finish downloading\";}  Thread A is running this method.      When Thread A hits line (line with await); Thread A will pause running (or stop running).  In this context, I prefer using pause, as it will resume running shortly.    ○ Why? Because there is a method with keyword ‘await’. ○ What is Thread A doing now? Either doing something else or stay idle; We don’t care.    Thread B start running the ‘someHttpDownloadTaskAync()’ method.  Some documents or articles refer this operation as a background operation.  Once Thread B completes the operation, Thread A will resume running this method.Database OperationThe following code snippet is a database operation.  Method 1 loads or fetches data from a database; and Method 2 persists data in database.  Both of them are asynchronous method.public async Task dbOperation() {    await loadDataFromDbAsync(); //method 1    await savingDataAsync(); //method 2}  Assuming the method is running on Thread A.  Thread A will pause running when it hits method 1. ○ Why? Because method 1 is asynchronous method and there is a keyword await.  In other word, any thread will be instructed to pause running when they hit method 1. ○ What will happen if we remove the await in front of method 1?  Simple. Thread A will continue running without any hesitation.  Because Thread A is not being instructed to pause and Thread A does not care about whether method 1 is asynchronous method or not.  We will discuss this scenario shortly.  At this stage, method 1 will start running on another thread and let’s called it Thread B. ○ What is Thread A doing now? We don’t know, either remain idle or doing something else.  Keep in mind, we don’t care.  When the operation of method 1 is completed.  Thread A will resume its operation again. ○ Where  does it resume from?  Simple, Thread A will start from the line underneath method 1.  In another word, it resume where it was paused.  Method 2 is a asynchronous method, same story as Method 1.  Thread A will need to pause again, another thread will start running method 2.What if the await keyword is missing in method 1async Task dbOperation() {    loadDataFromDbAsync(); //method 1    await savingDataAsync(); //method 2}  When the method is running Thread A.  Thread A will not pause, but continue running. ○ Why?  Because thread A is not told to wait, as the await keyword is missing  Since method 1 is an asynchronous method, another thread will start running this method 1.  At this stage, Thread A hits method 2 and pause running, as it is told to wait.It seems to be ok, but there is a implication.Assuming method 1 and method 1 are accessing the same database.    • Method 1 starts accessting the db context and it has not completed what it is doing.    • Since we did not tell Thread A to wait for (because we remove the await keyword) Method 1 completing accessing database.    • Probably, at the same time, Method 2 start its database operation as well. You may have encountered the following error in Visual Studio:  System.InvalidOperationException: A second operation started on this context before a previous operation completed. This is usually caused by different threads using the same DbContext instance.In the example above, both of the methods have a keyword await.  In other word, database operation in method 1 and 2 proceeds in sequence.ClarityAsynchronous programming is not about speed; using async/await does not necessarily mean program runs faster.Take AwayIt takes me some efforts to fully understand Asynchronous programming in C#.  Keep one thing in mind, within an asynchronous function, the thread will pause its operation while waiting for an (background) operation to be finished.  How do we know when the thread will pause? Simple, when it run into a line of code, starts with a keyword await and the method is an asynchronous method.      What is the thing it is not trying to block?    ○ It does not block other processes that are running or about to run in the application.        What is the thing it is waiting for?    ○ It is waiting for asynchronous functions that have been instructed to run asynchronously.  How to instruct them to run asynchronously? Put an await in front of the method.  "
  }
  
]

